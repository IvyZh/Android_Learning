![](https://github.com/IvyZh/Android_Learning/blob/master/DN/UI/imgs/QQ%E6%88%AA%E5%9B%BE.png)

录制时间：2016.07.22
老师:Ricky


### 事件传递

1. 事件传递机制--源码
2. 处理事件的冲突

在很多的滑动控件嵌套的情况下经常会出现滑动事件冲突等等。
在自定义控件的时候，需要处理触摸、点击、滑动等事件，需要考虑父容器的这些事件的冲突问题。

> 事件：Activity里面、View里面、ViewGroup里面、Key按键。

![](http://1)

![](http://2)

![](http://3)

onTouch的返回值改成true，然后看打印：

![](http://4)

发现onClick的log日志没有打印出来，这是为什么呢？

dispatchTouchEvent如何进行事件分发的？

分发有几种情况：

	onTouchListener-->onTouch方法
	
	onTouchEvent()
	
	onClickListener-->onClick方法


![](http://5)

![](http://6)

![](http://7)


结论：
	
	1.如果onTouchListener的onTouch方法返回了true，那么view里面的onTouchEvent就不会被调用了。

	顺序dispatchTouchEvent-->onTouchListener---return false-->onTouchEvent
	
	2.如果view为disenable,则：onTouchListener里面不会执行，但是会执行onTouchEvent(event)方法


performClick()


	3.onTouchEvent方法中的ACTION_UP分支中触发onclick事件监听
		onTouchListener-->onTouch方法返回true，消耗次事件。down,但是up事件是无法到达onClickListener.
		onTouchListener-->onTouch方法返回false，不会消耗此事件


实验：

![](http://8)

![](http://9)

打印情况：

![](http://10)

> 如果onTouchListener的onTouch方法返回了true，那么view里面的onTouchEvent就不会被调用了.就是先打印dispatch---onTouch


如果把onTouch改成返回false：

![](http://11)


打印情况：


![](http://12)


- 把MyButton的onTouchEvent的返回值改成true，

![](http://13)

结果：

![](http://14)

发现onClick事件没有了。


这样修改之后，就发现onClick事件又响应了。
![](http://15)

如果这个时候返回false，同时注释掉super：

![](http://16)

分析：

onTouchEvent的返回值来决定这个事件是否由自己来响应。

- false：事件就会由外部的RelativeLayout来响应onClick事件
- true：自己会响应

在做测试：打开super，返回false，结果：

![](http://17)

 
再改下dispatch 返回值true：

![](http://18)

dispatch 加上super 同时返回true：

![](http://19)

![](http://20)

这种情况下，所有的都是正常的。super.dispath 默认是返回true。


再改一下：


![](http://21)

效果：

![](http://22)

Button没有要这个down事件，给了父类，响应了父类的onClick点击事件。


再改一下：

![](http://23)

效果：

![](http://24)


up事件给父容器了，dispatch是起决定性作用，

dispatchTouchEvent默认是什么情况呢？

默认是true。


	小结：
	
	在很多的滑动控件嵌套的情况下经常会出现滑动事件冲突等等。
	在自定义控件的时候，需要处理触摸、点击、滑动等事件，需要考虑父容器的这些事件的冲突问题。
	
	事件传递：
		1.事件传递机制---源码。
		
		2.处理事件的冲突。
	
	事件：Activity里面、View里面、ViewGroup里面、Key按键。
	
	一、View的事件分发。
	结论：
		1.控件的Listener事件触发的顺序是先onTouch，再onClick。】
		2.控件的onTouch返回true，将会onClick事件没有了---阻止了事件的传递。
		  返回false，才会传递onClick事件(才会传递up事件)
	
	
	源码依据：
		View的事件分发
		1.dispatchTouchEvent（）；
		2.onTouchListener-->onTouch方法
		3.onTouchEvent()
		4.onClickListener-->onClick方法
	
	
	结论：
		1.如果onTouchListener的onTouch方法返回了true，那么view里面的onTouchEvent就不会被调用了。
	
	顺序dispatchTouchEvent-->onTouchListener---return false-->onTouchEvent
		2.如果view为disenable,则：onTouchListener里面不会执行，但是会执行onTouchEvent(event)方法
		  
		3.onTouchEvent方法中的ACTION_UP分支中触发onclick事件监听
			onTouchListener-->onTouch方法返回true，消耗次事件。down,但是up事件是无法到达onClickListener.
			onTouchListener-->onTouch方法返回false，不会消耗此事件




